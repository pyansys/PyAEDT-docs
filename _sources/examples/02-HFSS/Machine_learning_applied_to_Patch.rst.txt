
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\02-HFSS\Machine_learning_applied_to_Patch.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_02-HFSS_Machine_learning_applied_to_Patch.py:


HFSS: machine learning applied to a patch
---------------------------------------
This example shows how you can use PyAEDT to create a machine learning algorithm in three steps:

- Generate the database
- Create the machine learning algorithm
- Implement the model in a PyAEDT method

While this example supplies the code for all three steps in one Python file, it would be
better to separate the code for each step into its own Python file.

.. GENERATED FROM PYTHON SOURCE LINES 13-31

.. code-block:: default

    # Perform required imports
    # ~~~~~~~~~~~~~~~~~~~~~~~~
    # Perform required imports.

    import json
    import os
    import random
    from math import sqrt

    import joblib
    import numpy as np
    from sklearn.pipeline import make_pipeline
    from sklearn.preprocessing import StandardScaler
    from sklearn.svm import SVR

    from pyaedt import Hfss
    from pyaedt.modeler.stackup_3d import Stackup3D








.. GENERATED FROM PYTHON SOURCE LINES 32-35

Set non-graphical mode
~~~~~~~~~~~~~~~~~~~~~~
Set non-graphical mode. The default is ``False``.

.. GENERATED FROM PYTHON SOURCE LINES 35-38

.. code-block:: default


    non_graphical = os.getenv("PYAEDT_NON_GRAPHICAL", "False").lower() in ("true", "1", "t")








.. GENERATED FROM PYTHON SOURCE LINES 39-55

Generate database
-------------------
This section describes the first step, which is for generating the database.

Generate input
~~~~~~~~~~~~~~
Generate input randomly by creating a function with four inputs: frequency,
substrate permittivity, substrate thickness, and patch width. Frequency is
from 0.1 GHz to 1 GHz. Permittivity is from 1 to 12.

The following code generates a database of 1 frequency x 2 permittivity
x 2 thickness x 2 width. It creates eight cases, which are far too few to
use to train the model but are a sufficient number of cases for testing
the model. Later in this example, you import more than 3300 different 
cases in a previously-generated database of 74 frequencies
x 5 permittivity x 3 thickness x 3 width.

.. GENERATED FROM PYTHON SOURCE LINES 55-64

.. code-block:: default


    tuple_random_frequency_permittivity = []
    frequency_list = [150 * 1e6]
    for in_list in frequency_list:
        for i in range(2):
            random_permittivity = 1 + 11 * int(random.random() * 100) / 100
            temp_tuple = (in_list, random_permittivity)
            tuple_random_frequency_permittivity.append(temp_tuple)








.. GENERATED FROM PYTHON SOURCE LINES 65-75

Thickness is generated from 0.0025 to 0.055 of the wavelength in the void.
Width is generated from 0.5 to 1.5 of the optimal theoretical width:

c / (2 * frequency * sqrt((permittivity + 1) / 2))
#
For each couple of frequency-permittivity, three random thickness and three
random width are generated. Patch length is calculated using the analytic
formula. Using this formula is important because it reduces the sweep
frequency needed for the data recovery. Every case is stored in a list of a
dictionary.

.. GENERATED FROM PYTHON SOURCE LINES 75-124

.. code-block:: default


    dictionary_list = []
    c = 2.99792458e8
    for couple in tuple_random_frequency_permittivity:
        list_thickness = []
        list_width = []
        frequency = couple[0]
        permittivity = couple[1]
        er = permittivity
        wave_length_0 = c / frequency

        min_thickness = 0.0025 * wave_length_0
        inter_thickness = 0.01 * wave_length_0
        max_thickness = 0.055 * wave_length_0
        for i in range(2):
            random_int = random.randint(0, 1)
            if random_int == 0:
                thickness = min_thickness + (inter_thickness - min_thickness) * random.random()
            else:
                thickness = inter_thickness + (max_thickness - inter_thickness) * random.random()
            list_thickness.append(thickness)

        min_width = 0.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        max_width = 1.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        for i in range(2):
            width = min_width + (max_width - min_width) * random.random()
            list_width.append(width)

        for width in list_width:
            for thickness in list_thickness:
                effective_permittivity = (er + 1) / 2 + (er - 1) / (2 * sqrt(1 + 10 * thickness / width))
                er_e = effective_permittivity
                w_h = width / thickness
                added_length = 0.412 * thickness * (er_e + 0.3) * (w_h + 0.264) / ((er_e - 0.258) * (w_h + 0.813))
                wave_length = c / (frequency * sqrt(er_e))
                length = wave_length / 2 - 2 * added_length
                dictionary = {
                    "frequency": frequency,
                    "permittivity": permittivity,
                    "thickness": thickness,
                    "width": width,
                    "length": length,
                    "previous_impedance": 0,
                }
                dictionary_list.append(dictionary)

    print("List of data: " + str(dictionary_list))
    print("Its length is: " + str(len(dictionary_list)))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    List of data: [{'frequency': 150000000.0, 'permittivity': 5.62, 'thickness': 0.006557184938524613, 'width': 0.7570878638545467, 'length': 0.41915459515716985, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 5.62, 'thickness': 0.01839966730619539, 'width': 0.7570878638545467, 'length': 0.4141634739629022, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 5.62, 'thickness': 0.006557184938524613, 'width': 0.5759753712565236, 'length': 0.4202128146803666, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 5.62, 'thickness': 0.01839966730619539, 'width': 0.5759753712565236, 'length': 0.41666921775544213, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 4.63, 'thickness': 0.01517085014732825, 'width': 0.6616365566461422, 'length': 0.4596221032174744, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 4.63, 'thickness': 0.10376442831945804, 'width': 0.6616365566461422, 'length': 0.41204672586851643, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 4.63, 'thickness': 0.01517085014732825, 'width': 0.5205685782803936, 'length': 0.46178761672270435, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 4.63, 'thickness': 0.10376442831945804, 'width': 0.5205685782803936, 'length': 0.41893221311662576, 'previous_impedance': 0}]
    Its length is: 8




.. GENERATED FROM PYTHON SOURCE LINES 125-131

Generate HFSS design
~~~~~~~~~~~~~~~~~~~~
Generate the HFSS design using the PyAEDT ``Stackup3D`` function.
Open an HFSS design and create the stackup, add the different layers, and add
the patch. In the stackup library, most things, like the layers and patch,
are already parameterized.

.. GENERATED FROM PYTHON SOURCE LINES 131-143

.. code-block:: default


    desktopVersion = "2022.2"

    hfss = Hfss(new_desktop_session=True, solution_type="Terminal", non_graphical=non_graphical,
                specified_version=desktopVersion)

    stackup = Stackup3D(hfss)
    ground = stackup.add_ground_layer("ground", material="copper", thickness=0.035, fill_material="air")
    dielectric = stackup.add_dielectric_layer("dielectric", thickness=10, material="Duroid (tm)")
    signal = stackup.add_signal_layer("signal", material="copper", thickness=0.035, fill_material="air")
    patch = signal.add_patch(patch_length=1009.86, patch_width=1185.9, patch_name="Patch", frequency=100e6)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    pyaedt info: Logger Started
    pyaedt info: Launching PyAEDT outside AEDT with CPython and PythonNET.
    pyaedt info: AEDT installation Path C:\Program Files\AnsysEM\v222\Win64.
    pyaedt info: Launching AEDT with module PythonNET.
    pyaedt info: Ansoft.ElectronicsDesktop.2022.2 Started with process ID 956.
    pyaedt info: Logger file D:\Temp\pyaedt20220722_091734.log in use.
    pyaedt info: pyaedt v0.5.9
    pyaedt info: Python version 3.8.10 (tags/v3.8.10:3d8993a, May  3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)]
    pyaedt info: Project Project50 has been created.
    pyaedt info: No design is present. Inserting a new design.
    pyaedt info: Added design 'HFSS_1BN' of type HFSS.
    pyaedt info: Aedt Objects initialized
    pyaedt info: Variable Manager initialized
    pyaedt info: Design Loaded
    pyaedt info: Successfully loaded project materials !
    pyaedt info: Materials Loaded
    pyaedt warning: The closer the ratio between wave length and the width is to 1, the less correct the impedance calculation is
    The closer the ratio between wave length and the width is to 1, the less correct the impedance calculation is




.. GENERATED FROM PYTHON SOURCE LINES 144-147

Resize layers around patch
~~~~~~~~~~~~~~~~~~~~~~~~~~
Resise the layers around the patch so that they change when the patch changes.

.. GENERATED FROM PYTHON SOURCE LINES 147-150

.. code-block:: default


    stackup.resize_around_element(patch)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    True



.. GENERATED FROM PYTHON SOURCE LINES 151-154

Create lumped port
~~~~~~~~~~~~~~~~~~
Create a lumped port that is parametrized with the function of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 154-157

.. code-block:: default


    patch.create_lumped_port(reference_layer=ground, opposite_side=False, port_name="one")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    pyaedt info: Boundary AutoIdentify one has been correctly created.

    <pyaedt.modules.Boundary.BoundaryObject object at 0x000001828EA35E50>



.. GENERATED FROM PYTHON SOURCE LINES 158-162

Create line
~~~~~~~~~~~
Create a line that is parametrized with the function of the patch length. This
ensures that the air box is large enough in the normal direction of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 162-174

.. code-block:: default


    points_list = [
        [patch.position_x.name, patch.position_y.name, signal.elevation.name],
        [patch.position_x.name, patch.position_y.name, signal.elevation.name + " + " + patch.length.name],
    ]
    hfss.modeler.primitives.create_polyline(position_list=points_list, name="adjust_airbox")
    pad_percent = [50, 50, 300, 50, 50, 10]
    region = hfss.modeler.primitives.create_region(pad_percent)
    hfss.assign_radiation_boundary_to_objects(region)

    hfss.plot(show=False)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    pyaedt info: Boundary Radiation Rad__EH34NU has been correctly created.

    <pyaedt.generic.plot.ModelPlotter object at 0x000001828EA35F10>



.. GENERATED FROM PYTHON SOURCE LINES 175-178

Create setup and sweep
~~~~~~~~~~~~~~~~~~~~~~
Create a setup and a sweep by frequency.

.. GENERATED FROM PYTHON SOURCE LINES 178-206

.. code-block:: default


    print(len(dictionary_list))
    for freq in frequency_list:
        frequency_name = str(int(freq * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        current_setup = hfss.create_setup(setupname=setup_name)
        current_setup.props["Frequency"] = str(freq) + "Hz"
        current_setup.props["MaximumPasses"] = 30
        current_setup.props["MinimumConvergedPasses"] = 2
        current_setup.props["MaxDeltaS"] = 0.05
        current_setup.update()
        current_setup["SaveAnyFields"] = False

        freq_start = freq * 0.75
        freq_stop = freq * 1.25
        sweep_name = "Sweep_of_" + setup_name
        hfss.create_linear_count_sweep(
            setupname=setup_name,
            unit="Hz",
            freqstart=freq_start,
            freqstop=freq_stop,
            num_of_freq_points=25000,
            sweepname="Sweep_of_" + setup_name,
            save_fields=False,
            sweep_type="Interpolating",
        )






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    8
    pyaedt info: Linear count sweep Sweep_of_Setup_150 has been correctly created.




.. GENERATED FROM PYTHON SOURCE LINES 207-210

Define function
~~~~~~~~~~~~~~~
Define a function to recover the index of the resonance frequency.

.. GENERATED FROM PYTHON SOURCE LINES 210-234

.. code-block:: default



    def index_of_resonance(imaginary_list, real_list):
        list_of_index = []
        for i in range(1, len(imaginary_list)):
            if imaginary_list[i] * imaginary_list[i - 1] < 0:
                if abs(imaginary_list[i]) < abs(imaginary_list[i - 1]):
                    list_of_index.append(i)
                elif abs(imaginary_list[i]) > abs(imaginary_list[i - 1]):
                    list_of_index.append(i - 1)
        if len(list_of_index) == 0:
            return 0
        elif len(list_of_index) == 1:
            return list_of_index[0]
        else:
            storage = 0
            resonance_index = 0
            for index in list_of_index:
                if storage < real_list[index]:
                    storage = real_list[index]
                    resonance_index = index
            return resonance_index









.. GENERATED FROM PYTHON SOURCE LINES 235-244

Create parametric variation by case
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Use a loop to create parametric variation by case and associate it with a setup.
The parametric variation is composed of the patch length and width and substrate
permittivity and thickness. For each, measure the real resonance frequency to
obtain the data length, width, permittivity, and thickness that corresponds
to a resonance frequency. Use an error counter to verify that the resonance
frequency is contained in the sweep. To make it easy, calculate the length
of each case using the analytic formula.

.. GENERATED FROM PYTHON SOURCE LINES 244-313

.. code-block:: default


    error_counter = []
    for i in range(len(dictionary_list)):
        dictio = dictionary_list[i]
        frequency_name = str(int(dictio["frequency"] * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        sweep_name = "Sweep_of_" + setup_name
        length_variation = dictio["length"] * 1e3
        width_variation = dictio["width"] * 1e3
        thickness_variation = dictio["thickness"] * 1e3
        permittivity_variation = dictio["permittivity"]
        param_name = "para_" + setup_name + "_" + str(i)
        this_param = hfss.parametrics.add(
            patch.length.name,
            length_variation,
            length_variation,
            step=1,
            variation_type="LinearCount",
            solution=setup_name,
            parametricname=param_name,
        )
        this_param.add_variation(
            patch.width.name, width_variation, width_variation, step=1, unit=None, variation_type="LinearCount"
        )
        this_param.add_variation(
            dielectric.thickness.name,
            thickness_variation,
            thickness_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        this_param.add_variation(
            "$cloned_Duroid__tm__permittivity",
            permittivity_variation,
            permittivity_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        hfss.analyze_setup(param_name, num_cores=4, num_tasks=None)
        data = hfss.post.get_solution_data(
            "Zt(one_T1, one_T1)",
            setup_sweep_name=setup_name + " : " + sweep_name,
            domain="Sweep",
            variations={
                patch.length.name: [str(length_variation) + "mm"],
                patch.width.name: [str(width_variation) + "mm"],
                dielectric.thickness.name: [str(thickness_variation) + "mm"],
                "$cloned_Duroid__tm__permittivity": [str(permittivity_variation)],
            },
            polyline_points=25000,
        )
        imaginary_part = data.data_imag()
        real_part = data.data_real()
        corresponding_index = index_of_resonance(imaginary_part, real_part)
        if corresponding_index == 0:
            hfss.logger.error("The resonance is out of the range")
            error_counter.append(i)
        minimum_imaginary = imaginary_part[corresponding_index]
        previous_impedance = real_part[corresponding_index]
        print("minimum_imaginary: " + str(minimum_imaginary))
        print("previous_impedance: " + str(previous_impedance))
        frequency_list = data.primary_sweep_values
        resonance_frequency = frequency_list[corresponding_index]
        print(resonance_frequency)
        dictio["frequency"] = resonance_frequency
        dictio["previous_impedance"] = previous_impedance





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_0 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: 0.7292686871383622
    previous_impedance: 168.75418794404686
    0.137013980559222
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_1 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: -0.08777015464977966
    previous_impedance: 215.255732796879
    0.137770010800432
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_2 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: 0.49544479846764367
    previous_impedance: 227.52801639591377
    0.138934057362294
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_3 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: -0.4369382401557514
    previous_impedance: 280.70845128339187
    0.138526041041642
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_4 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: -0.455019091282732
    previous_impedance: 247.55629701282845
    0.14215018600744
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_5 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: 0.017286983598168264
    previous_impedance: 212.2048169775885
    0.137457998319933
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_6 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: 0.059603658745851315
    previous_impedance: 287.22230499776464
    0.14599033961358499
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Solving Optimetrics
    pyaedt info: Key Desktop/ActiveDSOConfigurations/HFSS correctly changed.
    pyaedt info: Design setup para_Setup_150_7 solved correctly
    pyaedt info: Solution Data Correctly Loaded.
    minimum_imaginary: -0.0641987163156049
    previous_impedance: 236.5600862704324
    0.13439487579503198




.. GENERATED FROM PYTHON SOURCE LINES 314-317

Print error
~~~~~~~~~~~
Print the number of range error.

.. GENERATED FROM PYTHON SOURCE LINES 317-320

.. code-block:: default


    print("number of range error: " + str(error_counter))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    number of range error: []




.. GENERATED FROM PYTHON SOURCE LINES 321-325

End data recovery step
~~~~~~~~~~~~~~~~~~~~~~
End the data recovery step by dumping the dictionary list into a JSON file.
Saving the data allows you to use it in another Python script.

.. GENERATED FROM PYTHON SOURCE LINES 325-330

.. code-block:: default


    json_file_path = os.path.join(hfss.working_directory, "ml_data_for_test.json")
    with open(json_file_path, "w") as readfile:
        json.dump(dictionary_list, readfile)








.. GENERATED FROM PYTHON SOURCE LINES 331-341

Create machine learning algorithm
----------------------------------
This section describes the second step, which is for creating the machine
learning algorithm.

Import training cases
~~~~~~~~~~~~~~~~~~~~~
Import the 3300 cases in the suppplied JSON file to train the model. As mentioned
earlier, you cannot use the small database that you generated earlier for training
the model. Its eight cases are used later to test the model.

.. GENERATED FROM PYTHON SOURCE LINES 341-353

.. code-block:: default


    path_folder = hfss.pyaedt_dir
    training_file = os.path.join(path_folder, "misc", "ml_data_file_train_100GMHz_1GHz.json")
    with open(training_file) as readfile:
        my_dictio_list_train = json.load(readfile)

    with open(json_file_path, "r") as readfile:
        my_dictio_list_test = json.load(readfile)

    print(len(my_dictio_list_train))
    print(len(my_dictio_list_test))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    3330
    8




.. GENERATED FROM PYTHON SOURCE LINES 354-362

Create lists
~~~~~~~~~~~~
Create four lists:

- one for the input of the training
- one for the output of training
- one for the input of the test
- one for the output of the test

.. GENERATED FROM PYTHON SOURCE LINES 362-369

.. code-block:: default



    input_for_training_list = []
    output_for_training_list = []
    input_for_test_list = []
    output_for_test_list = []








.. GENERATED FROM PYTHON SOURCE LINES 370-375

Fill list for input of training
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Fill the list for the input of the training with frequency, width, permittivity,
and thickness so that the output is the length. The objective of this
algorithm is to predict the length according to the rest.

.. GENERATED FROM PYTHON SOURCE LINES 375-401

.. code-block:: default


    for i in range(len(my_dictio_list_train)):
        freq_width_perm_thick = [
            my_dictio_list_train[i]["frequency"] * 1e9,
            my_dictio_list_train[i]["width"] * 1000,
            my_dictio_list_train[i]["permittivity"],
            my_dictio_list_train[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_train[i]["length"] * 1000
        input_for_training_list.append(freq_width_perm_thick)
        output_for_training_list.append(length)

    for i in range(len(my_dictio_list_test)):
        freq_width_perm_thick = [
            my_dictio_list_test[i]["frequency"] * 1e9,
            my_dictio_list_test[i]["width"] * 1000,
            my_dictio_list_test[i]["permittivity"],
            my_dictio_list_test[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_test[i]["length"] * 1000
        input_for_test_list.append(freq_width_perm_thick)
        output_for_test_list.append(length)

    print("number of test cases: " + str(len(output_for_test_list)))
    print("number of training cases: " + str(len(output_for_training_list)))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    number of test cases: 8
    number of training cases: 3330




.. GENERATED FROM PYTHON SOURCE LINES 402-405

Convert lists in array
~~~~~~~~~~~~~~~~~~~~~~
Convert the lists in an array.

.. GENERATED FROM PYTHON SOURCE LINES 405-414

.. code-block:: default


    input_for_training_array = np.array(input_for_training_list, dtype=np.float32)
    output_for_training_array = np.array(output_for_training_list, dtype=np.float32)
    input_for_test_array = np.array(input_for_test_list, dtype=np.float32)
    output_for_test_array = np.array(output_for_test_list, dtype=np.float32)

    print("input array for training: " + str(input_for_training_array))
    print("output array for training: " + str(output_for_training_array))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    input array for training: [[8.5343952e+07 1.8699978e+03 1.0000000e+00 1.3607236e+02]
     [8.7562560e+07 1.8699978e+03 1.0000000e+00 3.1649155e+01]
     [8.5523544e+07 1.8699978e+03 1.0000000e+00 1.6327014e+02]
     ...
     [9.5384678e+08 3.3421940e+01 1.1450000e+01 1.0995456e+01]
     [1.1057147e+09 3.3421940e+01 1.1450000e+01 2.1035936e+00]
     [9.7680755e+08 3.3421940e+01 1.1450000e+01 1.3259815e+01]]
    output array for training: [1463.626    1607.3876   1427.5016   ...   36.353287   39.326664
       35.355724]




.. GENERATED FROM PYTHON SOURCE LINES 415-436

Create model
~~~~~~~~~~~~
Create the model. Depending on the application, you can use different models.
The easiest way to find the correct model for an application is to search
for this application or one that is close to it.

To predict characteristics of a patch antenna (resonance frequency, bandwidth,
and input impedance), you can use SVR (Support Vector Regression) or ANN
(Analyze Neuronal Network). The following code uses SVR because it is easier
to implement. ANN is a more general method that also works with other
high frequency components. While is is more likely to work for other applications,
implenting ANN is
much more complex.

For SVR, there are three different kernels. For the patch antenna, Radial Basic
Function is preferred. There are three other arguments that have a big impact
on the accuracy of the model: C, gamma, and epsilon. Sometimes they are given
with the necessary model for the application. Otherwise, you can try different
values and see which one is the best by measuring the accuracy of the model.
To make this example shorter, C is equal to 1e4. However, the optimal value
in this application is 5e4.

.. GENERATED FROM PYTHON SOURCE LINES 436-440

.. code-block:: default


    svr_rbf = SVR(kernel="rbf", C=1e4, gamma="auto", epsilon=0.05)
    regression = make_pipeline(StandardScaler(), svr_rbf)








.. GENERATED FROM PYTHON SOURCE LINES 441-444

Train model
~~~~~~~~~~~
Train the model.

.. GENERATED FROM PYTHON SOURCE LINES 444-447

.. code-block:: default


    regression.fit(input_for_training_array, output_for_training_array)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" ><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" ><label for="sk-estimator-id-2" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler()</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" ><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">SVR</label><div class="sk-toggleable__content"><pre>SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;)</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 448-452

Dump model into JOBLIB file
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Dump the model into a JOBLIB file using the same method as you used earlier
for the JSON file.

.. GENERATED FROM PYTHON SOURCE LINES 452-456

.. code-block:: default


    model_file = os.path.join(hfss.working_directory, "svr_model.joblib")
    joblib.dump(regression, model_file)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    ['D:/Project/Project50.pyaedt\\HFSS_1BN\\svr_model.joblib']



.. GENERATED FROM PYTHON SOURCE LINES 457-466

Implement model in PyAEDT method
-------------------------------------
This section describes the third step, which is for implementating the model
in the PyAEDT method.

Load model
~~~~~~~~~~
Load the model in another Python file to predict different cases.
Here the correct model with C=5e4 is loaded rather than the one you made earlier.

.. GENERATED FROM PYTHON SOURCE LINES 466-470

.. code-block:: default


    model_path = os.path.join(path_folder, "misc", "patch_svr_model_100MHz_1GHz.joblib")
    regression = joblib.load(model_path)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:329: UserWarning: Trying to unpickle estimator StandardScaler from version 1.0.2 when using version 1.1.1. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:329: UserWarning: Trying to unpickle estimator SVR from version 1.0.2 when using version 1.1.1. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:329: UserWarning: Trying to unpickle estimator Pipeline from version 1.0.2 when using version 1.1.1. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(




.. GENERATED FROM PYTHON SOURCE LINES 471-475

Predict length of patch
~~~~~~~~~~~~~~~~~~~~~~~
Predict the length of a patch as a function of its resonant frequency and width
and substrate thickness and permittivity.

.. GENERATED FROM PYTHON SOURCE LINES 475-478

.. code-block:: default


    prediction_of_length = regression.predict(input_for_test_list)








.. GENERATED FROM PYTHON SOURCE LINES 479-482

Measure model efficiency
~~~~~~~~~~~~~~~~~~~~~~~~
Measure the model efficiency.

.. GENERATED FROM PYTHON SOURCE LINES 482-534

.. code-block:: default


    average_relative_gap = 0
    counter_under_zero_five = 0
    counter_under_one = 0
    counter_under_two = 0
    counter_under_five = 0
    counter_under_ten = 0
    counter_upper_ten = 0
    rel_counter_under_one = 0
    rel_counter_under_two = 0
    rel_counter_under_five = 0
    rel_counter_under_ten = 0
    rel_counter_under_twenty = 0
    rel_counter_upper_twenty = 0
    for index in range(len(prediction_of_length)):
        print(
            "value: "
            + str(input_for_test_list[index])
            + ", prediction: "
            + str(prediction_of_length[index] * 1000)
            + ", reality: "
            + str(output_for_test_list[index] * 1000)
        )
        gap = abs(prediction_of_length[index] - output_for_test_list[index])
        relative_gap = gap / output_for_test_list[index]
        average_relative_gap = average_relative_gap + relative_gap
        if gap < 0.5:
            counter_under_zero_five += 1
        elif 0.5 <= gap < 1:
            counter_under_one += 1
        elif 1 <= gap < 2:
            counter_under_two += 1
        elif 2 <= gap < 5:
            counter_under_five += 1
        elif 5 <= gap < 10:
            counter_under_ten += 1
        else:
            counter_upper_ten += 1
        if relative_gap < 0.01:
            rel_counter_under_one += 1
        elif relative_gap < 0.02:
            rel_counter_under_two += 1
        elif relative_gap < 0.05:
            rel_counter_under_five += 1
        elif relative_gap < 0.1:
            rel_counter_under_ten += 1
        elif relative_gap < 0.2:
            rel_counter_under_twenty += 1
        else:
            rel_counter_upper_twenty += 1
    average_relative_gap = average_relative_gap / len(prediction_of_length)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    value: [137013980.559222, 757.0878638545468, 5.62, 6.557184938524613], prediction: 435432.04455285193, reality: 419154.59515716985
    value: [137770010.800432, 757.0878638545468, 5.62, 18.39966730619539], prediction: 436654.63051119674, reality: 414163.4739629022
    value: [138934057.362294, 575.9753712565237, 5.62, 6.557184938524613], prediction: 432443.42087265133, reality: 420212.8146803666
    value: [138526041.041642, 575.9753712565237, 5.62, 18.39966730619539], prediction: 436393.4218671784, reality: 416669.21775544214
    value: [142150186.00744, 661.6365566461421, 4.63, 15.17085014732825], prediction: 476302.40743817965, reality: 459622.10321747436
    value: [137457998.319933, 661.6365566461421, 4.63, 103.76442831945803], prediction: 391963.1926188962, reality: 412046.7258685164
    value: [145990339.613585, 520.5685782803936, 4.63, 15.17085014732825], prediction: 463667.4905881714, reality: 461787.6167227043
    value: [134394875.795032, 520.5685782803936, 4.63, 103.76442831945803], prediction: 438848.9181053352, reality: 418932.21311662573




.. GENERATED FROM PYTHON SOURCE LINES 535-537

The first displays are the gap (prediction - real). The second displays are
the relative gap ((prediction - real)/real).

.. GENERATED FROM PYTHON SOURCE LINES 537-577

.. code-block:: default


    print("sample size: " + str(len(prediction_of_length)))
    print("<0.5 : " + str(counter_under_zero_five))
    print("<1 : " + str(counter_under_one))
    print("<2 : " + str(counter_under_two))
    print("<5 : " + str(counter_under_five))
    print("<10 : " + str(counter_under_ten))
    print(">10 : " + str(counter_upper_ten) + "\n")
    print(
        "sum : "
        + str(
            counter_under_zero_five
            + counter_under_one
            + counter_under_two
            + counter_under_five
            + counter_under_ten
            + counter_upper_ten
        )
    )

    print("-------------------------------------------\n")
    print("<0.01 : " + str(rel_counter_under_one))
    print("<0.02 : " + str(rel_counter_under_two))
    print("<0.05 : " + str(rel_counter_under_five))
    print("<0.1 : " + str(rel_counter_under_ten))
    print("<0.2 : " + str(rel_counter_under_twenty))
    print(">0.2 : " + str(rel_counter_upper_twenty))
    print(
        "sum : "
        + str(
            rel_counter_under_one
            + rel_counter_under_two
            + rel_counter_under_five
            + rel_counter_under_ten
            + rel_counter_under_twenty
            + rel_counter_upper_twenty
        )
    )
    print("average is : " + str(average_relative_gap))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    sample size: 8
    <0.5 : 0
    <1 : 0
    <2 : 1
    <5 : 0
    <10 : 0
    >10 : 7

    sum : 8
    -------------------------------------------

    <0.01 : 1
    <0.02 : 0
    <0.05 : 6
    <0.1 : 1
    <0.2 : 0
    >0.2 : 0
    sum : 8
    average is : 0.03827840968740454




.. GENERATED FROM PYTHON SOURCE LINES 578-581

Release AEDT
------------
Release AEDT.

.. GENERATED FROM PYTHON SOURCE LINES 581-583

.. code-block:: default


    hfss.release_desktop()




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    True




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 9 minutes  45.387 seconds)


.. _sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: Machine_learning_applied_to_Patch.py <Machine_learning_applied_to_Patch.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: Machine_learning_applied_to_Patch.ipynb <Machine_learning_applied_to_Patch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
